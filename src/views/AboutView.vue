<script lang="ts" setup>
import "@/styles/github-markdown.css"
import md from "@/markdown/markdown";

const markdownString: string = '### 第十届 Sky Hackathon 参赛项目书\n' +
  '\n' +
  '#### 描述一下你们的作品，包括亮点/特点，作品的功能和初衷\n' +
  '\n' +
  '本次Hackathon我们提交的作品，是一款基于RAG技术的国家标准检查工具。它提供了两个功能：\n' +
  '\n' +
  '1.\t输入国家标准文件 + 用户的问题，它会根据国家标准，解答用户在标准方面的疑惑。\n' +
  '2.\t输入国家标准文件 + 用户设计方案/产品参数表等，它会针对设计方案中的细节，搜寻与之对应的国家标准并进行比对检查，指出设计方案中与国家标准不符的问题点，或者合规方面的风险点，并给出对应国家标准。\n' +
  '\n' +
  '设计这个作品的灵感来源于我们日常工作中，经常涉及到标准化或合规问题。例如我们在设计API接口或者产品流程时，涉及到收集和存储用户信息的流程时，经常需要花费大量时间查阅标准文件或进行合规咨询。这时候如果我们能够利用RAG技术，对国家标准进行有针对性的解读，将大大提高工作效率。\n' +
  '\n' +
  '与此同时，针对已经设计、开发完成的产品，在进行多国家多地区部署的过程中，通常都要在当地进行合规认证。因此需要我们频繁地将产品设计文件与各个国家的标准进行比对，找出合规风险点并进行优化。这个过程不但大量消耗人力物力，在人工检查时还容易出现纰漏或理解错误，造成合规风险。因此我们希望通过RAG技术，针对产品设计方案进行整理，与标准文件进行对比，自动化找出合规方面的风险点。\n' +
  '\n' +
  '为什么选择使用RAG技术实现这个需求？我们认为RAG技术主要有两大优点：首先应用了RAG技术的大模型问答 答案准确性高。而标准与合规检查恰恰在准确性方面有这苛刻的要求。相比较于没有应用RAG技术的大模型，它可能对于标准比较问题含糊其辞，无法给出置信度较高的回答。\n' +
  '\n' +
  '其次，RAG有着知识更新成本低的优点。我们的标准文件（也就是RAG的知识库）通常来自各个国家或地区，每个地区的标准不尽相同，因此需要频繁对知识进行更新。这对于传统大模型来说训练成本是无法想象的，即使利用了微调技术，也需要大量的数据/时间来进行训练。\n' +
  '\n' +
  '除此之外，由于我们的所有问答和检查都基于给定的国家标准文件实现，问题发散程度低，因此RAG高度依赖外部知识库的缺点并不会对产品效果造成影响。\n' +
  '\n' +
  '综上所述，我们认为此产品完美发挥了RAG技术的优点，回避了RAG技术的缺点，是RAG的优秀使用场景。\n' +
  '\n' +
  '#### 描述一下你们利用AIGC工具来生成的内容\n' +
  '\n' +
  '对于用户提问功能，我们采用如下流程进行生成（为了方便理解，隐去了langchain document loader）：\n' +
  '\n' +
  '![用户提问流程图.jpg](https://cdn.jsdelivr.net/gh/LianQi-Kevin/Markdown_Image_Hosting@main/images/ee4ff5127df19697a200805ad3eebf4.jpg)\n' +
  '\n' +
  '针对产品设计检查功能，我们采用如下流程进行生成：\n' +
  '\n' +
  '![产品设计检查流程图.jpg](https://cdn.jsdelivr.net/gh/LianQi-Kevin/Markdown_Image_Hosting@main/images/32be2b3d79dcb4ec6bf107b125318bf.jpg)\n' +
  '\n' +
  '其中用户提问功能，是标准的RAG应用，即从用户问题中匹配到最与之相关的文档内容，与用户问题一起传入大模型，生成回答。\n' +
  '\n' +
  '而产品设计检查是对RAG的组合应用，它首先对用户设计方案进行分片处理，然后针对分片中提到的功能点，调用大模型进行相关标准生成，利用生成的标准与设计方案原始文本，进行多次retrieve，并对结果进行去重后，传入大模型生成回答。待每个分片都进行完回答后，由大模型对回答进行总结，输出最终结果。使用这种策略可以避免设计方案语言与国家标准语言之间的差异导致的匹配不准确问题，提升文档检索和匹配质量，继而让最终结果更全面更准确。\n' +
  '\n' +
  '#### 如果有， 描述一下你们是如何进行模型训练和推理\n' +
  '\n' +
  '本次Hackathon中我们并没有对模型层面进行改动和优化。但是在调用大模型方面，我们仍然可以从以下几个点进行优化和调优：\n' +
  '\n' +
  '1.\tPrompt优化：通过优化Prompt，可以帮助大模型给出更加准确、全面、有条理的答案。在此我们的优化方法主要是参考行业优秀Prompt写法，针对我们的需求撰写Prompt。同时进行多轮、多场景测试，发现大模型答案中的不足，例如凭空臆造国家标准、出现多余的提示词等。通过在Prompt中给予提示，帮助大模型规避掉这些问题。\n' +
  '2.\t大语言模型和Embedding模型选择：NVIDIA NMI平台为我们提供了丰富的模型库，我们在选择模型时会首先检查模型的训练数据，选取训练数据中形式语言占比较高的模型，并经过多轮测试，针对作品中的两个功能分别选择了最适合的大语言模型。\n' +
  '3.\t调整分片大小：通过调整读取国家标准文档、及用户设计文档时的分片大小，我们可以让抽取出来的信息更精准、精炼，从而减少token数，加快大模型推理速度和精确度。\n' +
  '4.\t调整Temperature：通过多轮测试，为大模型指定合适的Temperature，从而帮助大模型产生出更精准的结果。\n' +
  '\n' +
  '#### 描述一下你们的技术创新点，包括但不限于在组委会提供的技术点\n' +
  '\n' +
  '在本次作品中，我们的创新点主要体现在：\n' +
  '\n' +
  '1.\t应用场景创新：结合RAG技术的优势以及实际工作中的痛点，为用户提供了设计方案检查和国家标准提问的功能。\n' +
  '2.\tRetrieve优化方法创新：在产品设计检查功能中，我们对Retrieve的方法进行了创新。传统Retrieve通常直接使用用户的问题进行Retrieve，而在这个场景中，产品的涉及文档与国家标准文件在语言上通常有较大差异。例如设计文档中对一个API的定义是：要求用户填写手机号、邮箱、生日和住址，但国家标准中与之相关的规定是：“收集的个人信息的类型应与实现产品或服务的业务功能有直接关联”。在此过程中，如果直接使用文字相似度，可能无法准确匹配到信息。因此我们利用大语言模型，将产品设计文档中的语言改写为国家标准的形式语言，再进行匹配，使得匹配准确度得到了提高。\n' +
  '\n' +
  '\n' +
  '#### 总结（团队收获）\n' +
  '\n' +
  '通过本次比赛，我们学习了RAG技术的基本概念以及常见优化方法，以及Gradio、FastAPI、Langchain等架构的使用方法，并通过实践应用加深了对框架的理解，总结出了框架的常见问题及解决方法。\n' +
  '\n' +
  '尽管我们的产品顺利完成了所设计的功能，并且在多数日常场景下有着良好的表现，但仍然有以下几个值得优化的地方：\n' +
  '\n' +
  '1.\t对图片的理解有待加强：部分行业的国家标准（如建筑行业），许多规范无法仅靠文字说明，无论是国家标准还是用户的设计方案中都会出现大量的示意图。而大语言模型对图像的理解显然有待加强。因此在真实行业应用中，我们希望能通过引入更丰富的模型种类，或者引入各专业领域的图像处理类库、设计软件API等，实现对这部分标准的解析、检查。\n' +
  '2.\t针对国家标准的Document Loader：通常情况下，国家标准都以格式统一的pdf文件出现，在本项目中我们使用了langchain提供的PyPDFLoader对国家标准文件进行解析。但是在实际应用过程中，部分情况下仍然会出现文档排版混乱、解析错误甚至乱码情况发生。针对国家标准文档保有量很大的现状，在未来我们希望能够实现一个类似ArxivLoader的专用加载器，以便输出格式更加清晰、内容更准确的文档内容，进而优化分片和检索效果，提升大模型输出质量。\n' +
  '3.\t选取更适合标准检查场景的LLM模型：目前我们选取的仍然是通用大语言模型，如果在未来我们有能力训练或微调自己的大语言模型，我们希望针对此业务训练专用的大语言模型，在训练数据上多使用法律文书、设计方案、国家标准等形式化语言，继而在此类问题上大大提高最终结果的准确性。\n'
</script>

<template>
  <div class="aboutContainer">
    <article ref="codeBlocksContainer" class="markdown-body">
      <div class="markdown" v-html="md.render(markdownString)"/>
    </article>
  </div>
</template>

<style>
.aboutContainer {
  max-width: 1200px;
  margin: 20px auto;
  overflow-x: hidden;

  img {
    display: block;
    max-width: 80%;
    margin: 0 auto;
  }
}

@media screen and (max-width: 1200px) {
  .aboutContainer {
    padding: 0 20px;

    img {
      max-width: 100%;
    }
  }
}
</style>
